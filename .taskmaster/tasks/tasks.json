{
  "tasks": [
    {
      "id": 1,
      "title": "Refactor Core Architecture",
      "description": "Restructure the codebase to improve maintainability by implementing the system components outlined in the PRD: ContextTracker, Configuration Manager, File Filter System, and Output Formatter.",
      "details": "Create a modular architecture with clear separation of concerns:\n\n1. Implement ContextTracker class:\n```typescript\nexport class ContextTracker {\n  private fileWatcher: vscode.FileSystemWatcher;\n  private configManager: ConfigurationManager;\n  private fileFilter: FileFilterSystem;\n  private outputFormatter: OutputFormatter;\n\n  constructor() {\n    this.configManager = new ConfigurationManager();\n    this.fileFilter = new FileFilterSystem(this.configManager);\n    this.outputFormatter = new OutputFormatter(this.configManager);\n    this.initializeWatchers();\n  }\n\n  private initializeWatchers(): void {\n    // Initialize file watchers using VS Code API\n  }\n\n  public trackOpenFiles(): void {\n    // Track currently open files\n  }\n\n  public generateOutput(): void {\n    // Generate output based on current context\n  }\n}\n```\n\n2. Use dependency injection for better testability\n3. Implement proper error handling with try/catch blocks\n4. Add comprehensive logging using VS Code's output channel\n5. Use TypeScript interfaces for all data models\n\nUse VS Code Extension API v1.84.0+ and Node.js 16+. Set up the project with TypeScript 5.0+ for improved type safety.",
      "testStrategy": "1. Write unit tests for each core class using Mocha and Sinon for mocking\n2. Create integration tests that verify component interactions\n3. Test error handling by simulating failure scenarios\n4. Verify proper cleanup of resources and event listeners",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Implement Configuration Manager",
      "description": "Develop a robust Configuration Manager to handle extension settings, validation, and real-time updates without requiring extension restart.",
      "details": "Create a ConfigurationManager class that handles all configuration aspects:\n\n```typescript\nexport interface ExtensionConfig {\n  outputPaths: string[];\n  formats: OutputFormat[];\n  enableGitignore: boolean;\n  includePinnedTabs: boolean;\n  excludePatterns: string[];\n}\n\nexport interface OutputFormat {\n  id: string;\n  template: string;\n  path: string;\n  prependContent?: string;\n}\n\nexport class ConfigurationManager {\n  private config: ExtensionConfig;\n  private configChangeListener: vscode.Disposable;\n\n  constructor() {\n    this.config = this.loadConfiguration();\n    this.setupConfigChangeListener();\n  }\n\n  private loadConfiguration(): ExtensionConfig {\n    // Load from VS Code settings\n  }\n\n  private setupConfigChangeListener(): void {\n    // Listen for configuration changes\n    this.configChangeListener = vscode.workspace.onDidChangeConfiguration(e => {\n      if (e.affectsConfiguration('autoCopilotContext')) {\n        this.config = this.loadConfiguration();\n        this.notifyConfigChanged();\n      }\n    });\n  }\n\n  private notifyConfigChanged(): void {\n    // Notify subscribers of config changes\n  }\n\n  public getConfig(): ExtensionConfig {\n    return this.config;\n  }\n\n  public validateConfig(): string[] {\n    // Return array of validation errors\n  }\n\n  public dispose(): void {\n    this.configChangeListener.dispose();\n  }\n}\n```\n\nImplement configuration validation to ensure all settings are valid before applying them. Use VS Code's configuration API (workspace.getConfiguration) for reading settings and provide sensible defaults for all options. Support workspace-specific configurations using scoped configuration.",
      "testStrategy": "1. Test configuration loading with various input scenarios\n2. Verify validation logic catches invalid configurations\n3. Test real-time configuration updates\n4. Ensure proper event emission when configuration changes\n5. Test workspace vs user settings precedence",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Develop File Filter System with Gitignore Integration",
      "description": "Create a file filtering system that respects .gitignore rules and implements smart filtering to exclude irrelevant files based on configuration settings.",
      "details": "Implement a FileFilterSystem class that handles all file filtering logic:\n\n```typescript\nexport class FileFilterSystem {\n  private configManager: ConfigurationManager;\n  private gitignorePatterns: string[] = [];\n  private gitignoreParser: any; // Use ignore package\n\n  constructor(configManager: ConfigurationManager) {\n    this.configManager = configManager;\n    this.gitignoreParser = require('ignore')();\n    this.loadGitignorePatterns();\n  }\n\n  private loadGitignorePatterns(): void {\n    // Find and parse .gitignore files in workspace\n    const gitignorePath = path.join(vscode.workspace.rootPath || '', '.gitignore');\n    if (fs.existsSync(gitignorePath)) {\n      const content = fs.readFileSync(gitignorePath, 'utf8');\n      this.gitignorePatterns = content.split('\\n').filter(line => {\n        return line.trim() && !line.startsWith('#');\n      });\n      this.gitignoreParser.add(this.gitignorePatterns);\n    }\n  }\n\n  public shouldIncludeFile(filePath: string): boolean {\n    const config = this.configManager.getConfig();\n    \n    // Check if file is in output paths to avoid recursive inclusion\n    if (config.outputPaths.some(p => filePath.includes(p))) {\n      return false;\n    }\n    \n    // Check custom exclude patterns\n    for (const pattern of config.excludePatterns) {\n      if (minimatch(filePath, pattern)) {\n        return false;\n      }\n    }\n    \n    // Check gitignore if enabled\n    if (config.enableGitignore) {\n      const relativePath = path.relative(vscode.workspace.rootPath || '', filePath);\n      if (this.gitignoreParser.ignores(relativePath)) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n}\n```\n\nUse the 'ignore' npm package (version 5.2.4+) for gitignore parsing and 'minimatch' (version 5.1.0+) for pattern matching. Implement caching of filter results to improve performance for large workspaces. Add support for custom file extensions and patterns defined in the configuration.",
      "testStrategy": "1. Test gitignore pattern parsing with various .gitignore files\n2. Verify file filtering logic with different file paths\n3. Test custom exclude patterns from configuration\n4. Benchmark performance with large file sets\n5. Test edge cases like nested .gitignore files",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Implement Output Formatter with Template System",
      "description": "Create a flexible output formatter that supports customizable templates with variable substitution and multiple output formats for different AI systems.",
      "details": "Develop an OutputFormatter class that handles template processing and multi-format support:\n\n```typescript\nexport class OutputFormatter {\n  private configManager: ConfigurationManager;\n  \n  constructor(configManager: ConfigurationManager) {\n    this.configManager = configManager;\n  }\n  \n  public formatOutput(files: FileData[]): Map<string, string> {\n    const config = this.configManager.getConfig();\n    const outputs = new Map<string, string>();\n    \n    for (const format of config.formats) {\n      let output = format.template;\n      \n      // Process template variables\n      output = output.replace('{{files}}', this.formatFiles(files, format));\n      output = output.replace('{{fileCount}}', files.length.toString());\n      output = output.replace('{{timestamp}}', new Date().toISOString());\n      \n      // Add prepend content if specified\n      if (format.prependContent) {\n        output = format.prependContent + output;\n      }\n      \n      outputs.set(format.path, output);\n    }\n    \n    return outputs;\n  }\n  \n  private formatFiles(files: FileData[], format: OutputFormat): string {\n    // Format files according to template\n    // This could be JSON, markdown, or custom format\n  }\n}\n```\n\nImplement support for various output formats including JSON, Markdown, and plain text. Create a flexible template system with variable substitution for file paths, content, and metadata. Support custom delimiters and formatting options. Use a streaming approach for large files to minimize memory usage.",
      "testStrategy": "1. Test template processing with various input templates\n2. Verify variable substitution works correctly\n3. Test different output formats (JSON, Markdown, etc.)\n4. Test with large file sets to ensure performance\n5. Verify proper handling of special characters and escaping",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Implement File Monitoring System",
      "description": "Develop a robust file monitoring system that tracks open files, tab changes, and file modifications in real-time to keep context up-to-date.",
      "details": "Create a comprehensive file monitoring system that tracks all relevant VS Code events:\n\n```typescript\nexport class FileMonitor {\n  private disposables: vscode.Disposable[] = [];\n  private openFiles: Set<string> = new Set();\n  private pinnedTabs: Set<string> = new Set();\n  private onFilesChangedEmitter = new vscode.EventEmitter<void>();\n  \n  public readonly onFilesChanged = this.onFilesChangedEmitter.event;\n  \n  constructor() {\n    this.initializeListeners();\n    this.trackInitialState();\n  }\n  \n  private initializeListeners(): void {\n    // Track when files are opened\n    this.disposables.push(\n      vscode.window.onDidChangeActiveTextEditor(editor => {\n        if (editor && editor.document.uri.scheme === 'file') {\n          this.openFiles.add(editor.document.uri.fsPath);\n          this.notifyChanges();\n        }\n      })\n    );\n    \n    // Track when files are closed\n    this.disposables.push(\n      vscode.workspace.onDidCloseTextDocument(document => {\n        if (document.uri.scheme === 'file') {\n          this.openFiles.delete(document.uri.fsPath);\n          this.pinnedTabs.delete(document.uri.fsPath);\n          this.notifyChanges();\n        }\n      })\n    );\n    \n    // Track when files are modified\n    this.disposables.push(\n      vscode.workspace.onDidChangeTextDocument(event => {\n        if (event.document.uri.scheme === 'file') {\n          this.notifyChanges();\n        }\n      })\n    );\n    \n    // Track pinned tabs (requires VS Code API 1.84.0+)\n    this.disposables.push(\n      vscode.window.tabGroups.onDidChangeTabs(tabs => {\n        for (const tab of tabs) {\n          if (tab.input instanceof vscode.TabInputText && tab.isPinned) {\n            this.pinnedTabs.add(tab.input.uri.fsPath);\n          }\n        }\n        this.notifyChanges();\n      })\n    );\n  }\n  \n  private trackInitialState(): void {\n    // Track currently open editors\n    vscode.window.visibleTextEditors.forEach(editor => {\n      if (editor.document.uri.scheme === 'file') {\n        this.openFiles.add(editor.document.uri.fsPath);\n      }\n    });\n    \n    // Track currently pinned tabs\n    vscode.window.tabGroups.all.forEach(group => {\n      group.tabs.forEach(tab => {\n        if (tab.input instanceof vscode.TabInputText && tab.isPinned) {\n          this.pinnedTabs.add(tab.input.uri.fsPath);\n        }\n      });\n    });\n    \n    this.notifyChanges();\n  }\n  \n  private notifyChanges(): void {\n    this.onFilesChangedEmitter.fire();\n  }\n  \n  public getOpenFiles(): string[] {\n    return Array.from(this.openFiles);\n  }\n  \n  public getPinnedTabs(): string[] {\n    return Array.from(this.pinnedTabs);\n  }\n  \n  public dispose(): void {\n    this.disposables.forEach(d => d.dispose());\n    this.onFilesChangedEmitter.dispose();\n  }\n}\n```\n\nUse VS Code's API for tracking file changes, including onDidChangeActiveTextEditor, onDidCloseTextDocument, and onDidChangeTextDocument. Implement debouncing to avoid excessive updates during rapid file changes. Use the TabGroups API (introduced in VS Code 1.84.0) to track pinned tabs.",
      "testStrategy": "1. Test file tracking with various editor operations (open, close, edit)\n2. Verify pinned tab detection works correctly\n3. Test debouncing logic with rapid file changes\n4. Verify proper cleanup of event listeners\n5. Test with multiple editor groups and windows",
      "priority": "high",
      "dependencies": [
        1,
        3
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement File Content Caching for Performance",
      "description": "Develop a caching system for file contents to improve performance and reduce disk I/O, especially for large codebases.",
      "details": "Create a FileCache class that efficiently manages file content caching:\n\n```typescript\ninterface CacheEntry {\n  content: string;\n  timestamp: number;\n  size: number;\n}\n\nexport class FileCache {\n  private cache: Map<string, CacheEntry> = new Map();\n  private maxCacheSize: number = 50 * 1024 * 1024; // 50MB default\n  private currentCacheSize: number = 0;\n  \n  constructor(maxCacheSizeMB?: number) {\n    if (maxCacheSizeMB) {\n      this.maxCacheSize = maxCacheSizeMB * 1024 * 1024;\n    }\n  }\n  \n  public async getFileContent(filePath: string): Promise<string> {\n    // Check if file is in cache and not modified\n    const stats = await fs.promises.stat(filePath);\n    const cacheEntry = this.cache.get(filePath);\n    \n    if (cacheEntry && cacheEntry.timestamp >= stats.mtime.getTime()) {\n      return cacheEntry.content;\n    }\n    \n    // Read file content\n    const content = await fs.promises.readFile(filePath, 'utf8');\n    \n    // Update cache\n    this.addToCache(filePath, content, stats.mtime.getTime());\n    \n    return content;\n  }\n  \n  private addToCache(filePath: string, content: string, timestamp: number): void {\n    const size = Buffer.byteLength(content, 'utf8');\n    \n    // Remove old entry if exists\n    if (this.cache.has(filePath)) {\n      const oldEntry = this.cache.get(filePath)!;\n      this.currentCacheSize -= oldEntry.size;\n    }\n    \n    // Check if we need to make room in the cache\n    if (this.currentCacheSize + size > this.maxCacheSize) {\n      this.evictOldEntries(size);\n    }\n    \n    // Add to cache\n    this.cache.set(filePath, { content, timestamp, size });\n    this.currentCacheSize += size;\n  }\n  \n  private evictOldEntries(sizeNeeded: number): void {\n    // Sort entries by timestamp (oldest first)\n    const entries = Array.from(this.cache.entries())\n      .sort((a, b) => a[1].timestamp - b[1].timestamp);\n    \n    // Remove oldest entries until we have enough space\n    for (const [path, entry] of entries) {\n      if (this.currentCacheSize + sizeNeeded <= this.maxCacheSize) {\n        break;\n      }\n      \n      this.cache.delete(path);\n      this.currentCacheSize -= entry.size;\n    }\n  }\n  \n  public clearCache(): void {\n    this.cache.clear();\n    this.currentCacheSize = 0;\n  }\n  \n  public getCacheStats(): { entryCount: number, sizeBytes: number } {\n    return {\n      entryCount: this.cache.size,\n      sizeBytes: this.currentCacheSize\n    };\n  }\n}\n```\n\nImplement an LRU (Least Recently Used) eviction policy to manage cache size. Use file modification timestamps to detect changes and invalidate cache entries. Make the cache size configurable through extension settings. Implement lazy loading to only read files when needed.",
      "testStrategy": "1. Test cache hit/miss scenarios with various file operations\n2. Verify cache eviction works correctly when size limit is reached\n3. Test cache invalidation when files are modified\n4. Benchmark performance improvement compared to direct file reading\n5. Test with large files to ensure memory usage is controlled",
      "priority": "medium",
      "dependencies": [
        5
      ],
      "status": "deferred",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement Error Handling and Logging System",
      "description": "Develop a comprehensive error handling and logging system to improve reliability and provide better feedback to users.",
      "details": "Create a Logger class that handles all logging and error reporting:\n\n```typescript\nexport enum LogLevel {\n  DEBUG = 0,\n  INFO = 1,\n  WARN = 2,\n  ERROR = 3\n}\n\nexport class Logger {\n  private outputChannel: vscode.OutputChannel;\n  private logLevel: LogLevel;\n  \n  constructor(name: string, level: LogLevel = LogLevel.INFO) {\n    this.outputChannel = vscode.window.createOutputChannel(name);\n    this.logLevel = level;\n  }\n  \n  public setLogLevel(level: LogLevel): void {\n    this.logLevel = level;\n  }\n  \n  public debug(message: string, ...data: any[]): void {\n    if (this.logLevel <= LogLevel.DEBUG) {\n      this.log('DEBUG', message, data);\n    }\n  }\n  \n  public info(message: string, ...data: any[]): void {\n    if (this.logLevel <= LogLevel.INFO) {\n      this.log('INFO', message, data);\n    }\n  }\n  \n  public warn(message: string, ...data: any[]): void {\n    if (this.logLevel <= LogLevel.WARN) {\n      this.log('WARN', message, data);\n      vscode.window.showWarningMessage(`[Auto Copilot Context] ${message}`);\n    }\n  }\n  \n  public error(message: string, error?: Error, ...data: any[]): void {\n    if (this.logLevel <= LogLevel.ERROR) {\n      this.log('ERROR', message, data);\n      if (error) {\n        this.outputChannel.appendLine(`Stack: ${error.stack || 'No stack trace available'}`);\n      }\n      vscode.window.showErrorMessage(`[Auto Copilot Context] ${message}`);\n    }\n  }\n  \n  private log(level: string, message: string, data: any[]): void {\n    const timestamp = new Date().toISOString();\n    this.outputChannel.appendLine(`[${timestamp}] [${level}] ${message}`);\n    if (data.length > 0) {\n      this.outputChannel.appendLine(JSON.stringify(data, null, 2));\n    }\n  }\n  \n  public show(): void {\n    this.outputChannel.show();\n  }\n  \n  public dispose(): void {\n    this.outputChannel.dispose();\n  }\n}\n```\n\nImplement a global error handler to catch and log unhandled exceptions. Use try/catch blocks in all async operations. Provide user-friendly error messages through VS Code's notification API. Make log level configurable through extension settings. Add telemetry for error reporting (with user consent).",
      "testStrategy": "1. Test different log levels and verify appropriate output\n2. Verify error notifications appear correctly\n3. Test error handling in various failure scenarios\n4. Verify stack traces are properly captured and logged\n5. Test performance impact of logging in high-volume scenarios",
      "priority": "medium",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement Command Palette Integration",
      "description": "Add VS Code command palette integration for manual context refresh and other extension actions.",
      "details": "Register commands with VS Code's command palette for manual control of the extension:\n\n```typescript\nexport function registerCommands(context: vscode.ExtensionContext, contextTracker: ContextTracker): void {\n  // Register command to manually refresh context\n  context.subscriptions.push(\n    vscode.commands.registerCommand('autoCopilotContext.refreshContext', () => {\n      vscode.window.withProgress(\n        {\n          location: vscode.ProgressLocation.Notification,\n          title: 'Refreshing context...',\n          cancellable: false\n        },\n        async () => {\n          await contextTracker.generateOutput();\n          vscode.window.showInformationMessage('Context refreshed successfully');\n        }\n      );\n    })\n  );\n  \n  // Register command to show output channel\n  context.subscriptions.push(\n    vscode.commands.registerCommand('autoCopilotContext.showLogs', () => {\n      // Show logs output channel\n    })\n  );\n  \n  // Register command to clear cache\n  context.subscriptions.push(\n    vscode.commands.registerCommand('autoCopilotContext.clearCache', () => {\n      // Clear file cache\n      vscode.window.showInformationMessage('Cache cleared successfully');\n    })\n  );\n  \n  // Register command to toggle extension\n  context.subscriptions.push(\n    vscode.commands.registerCommand('autoCopilotContext.toggle', () => {\n      const config = vscode.workspace.getConfiguration('autoCopilotContext');\n      const currentValue = config.get<boolean>('enabled');\n      config.update('enabled', !currentValue, true);\n      vscode.window.showInformationMessage(\n        `Auto Copilot Context ${!currentValue ? 'enabled' : 'disabled'}`\n      );\n    })\n  );\n}\n```\n\nImplement progress indicators for long-running operations. Add keyboard shortcuts for common commands. Create a status bar item to show extension status and provide quick access to commands. Add command descriptions in package.json for better discoverability.",
      "testStrategy": "1. Test each command to verify correct functionality\n2. Verify progress indicators work correctly for long operations\n3. Test keyboard shortcuts to ensure they trigger the correct commands\n4. Verify status bar item updates correctly based on extension state\n5. Test command registration and disposal during extension lifecycle",
      "priority": "low",
      "dependencies": [
        1,
        5
      ],
      "status": "deferred",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Workspace-Specific Configurations",
      "description": "Add support for workspace-specific configurations to allow different settings for different projects.",
      "details": "Enhance the Configuration Manager to support workspace-specific settings:\n\n```typescript\nexport class ConfigurationManager {\n  // ... existing code ...\n  \n  private loadConfiguration(): ExtensionConfig {\n    const config = vscode.workspace.getConfiguration('autoCopilotContext');\n    \n    // Check if we have a workspace folder\n    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n    \n    // Load workspace-specific configuration file if it exists\n    let workspaceConfig: Partial<ExtensionConfig> = {};\n    if (workspaceFolder) {\n      const configPath = path.join(workspaceFolder.uri.fsPath, '.vscode/auto-copilot-context.json');\n      if (fs.existsSync(configPath)) {\n        try {\n          workspaceConfig = JSON.parse(fs.readFileSync(configPath, 'utf8'));\n        } catch (error) {\n          // Log error but continue with default config\n        }\n      }\n    }\n    \n    // Merge configurations with workspace taking precedence\n    return {\n      outputPaths: workspaceConfig.outputPaths || config.get<string[]>('outputPaths', []),\n      formats: workspaceConfig.formats || config.get<OutputFormat[]>('formats', []),\n      enableGitignore: workspaceConfig.enableGitignore !== undefined ? \n        workspaceConfig.enableGitignore : config.get<boolean>('enableGitignore', true),\n      includePinnedTabs: workspaceConfig.includePinnedTabs !== undefined ? \n        workspaceConfig.includePinnedTabs : config.get<boolean>('includePinnedTabs', true),\n      excludePatterns: workspaceConfig.excludePatterns || config.get<string[]>('excludePatterns', [])\n    };\n  }\n  \n  // Add method to create default workspace config\n  public createDefaultWorkspaceConfig(): void {\n    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];\n    if (!workspaceFolder) {\n      return;\n    }\n    \n    const vscodeDir = path.join(workspaceFolder.uri.fsPath, '.vscode');\n    const configPath = path.join(vscodeDir, 'auto-copilot-context.json');\n    \n    // Create .vscode directory if it doesn't exist\n    if (!fs.existsSync(vscodeDir)) {\n      fs.mkdirSync(vscodeDir);\n    }\n    \n    // Don't overwrite existing config\n    if (fs.existsSync(configPath)) {\n      return;\n    }\n    \n    // Create default config\n    const defaultConfig: ExtensionConfig = {\n      outputPaths: ['.vscode/copilot-context.json'],\n      formats: [\n        {\n          id: 'json',\n          template: '{\"files\": {{files}}}',\n          path: '.vscode/copilot-context.json'\n        }\n      ],\n      enableGitignore: true,\n      includePinnedTabs: true,\n      excludePatterns: ['**/.git/**', '**/node_modules/**']\n    };\n    \n    fs.writeFileSync(configPath, JSON.stringify(defaultConfig, null, 2));\n  }\n}\n```\n\nImplement a command to create a default workspace configuration file. Add support for multiple workspace folders. Provide schema validation for workspace configuration files. Add documentation for workspace configuration options.",
      "testStrategy": "1. Test loading of workspace-specific configuration files\n2. Verify correct merging of workspace and user settings\n3. Test creation of default workspace configuration\n4. Verify configuration changes are detected in workspace files\n5. Test with multiple workspace folders to ensure correct behavior",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "deferred",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Implement Multi-Output Support",
      "description": "Enhance the extension to support generating multiple output files simultaneously with different formats for different AI systems.",
      "details": "Extend the OutputFormatter to support multiple output formats and destinations:\n\n```typescript\nexport interface OutputFormat {\n  id: string;\n  template: string;\n  path: string;\n  prependContent?: string;\n  fileFormat?: 'json' | 'markdown' | 'text';\n  maxFiles?: number;\n  includeContent?: boolean;\n}\n\nexport class OutputManager {\n  private configManager: ConfigurationManager;\n  private outputFormatter: OutputFormatter;\n  private logger: Logger;\n  \n  constructor(configManager: ConfigurationManager, outputFormatter: OutputFormatter, logger: Logger) {\n    this.configManager = configManager;\n    this.outputFormatter = outputFormatter;\n    this.logger = logger;\n  }\n  \n  public async generateOutputs(files: FileData[]): Promise<void> {\n    const config = this.configManager.getConfig();\n    const formattedOutputs = this.outputFormatter.formatOutput(files);\n    \n    for (const [outputPath, content] of formattedOutputs.entries()) {\n      try {\n        // Ensure directory exists\n        const dirPath = path.dirname(outputPath);\n        if (!fs.existsSync(dirPath)) {\n          fs.mkdirSync(dirPath, { recursive: true });\n        }\n        \n        // Write output file\n        await fs.promises.writeFile(outputPath, content, 'utf8');\n        this.logger.info(`Generated output: ${outputPath}`);\n      } catch (error) {\n        this.logger.error(`Failed to write output to ${outputPath}`, error as Error);\n      }\n    }\n  }\n}\n```\n\nImplement support for different file formats including JSON, Markdown, and plain text. Add template variables for customizing output format. Support relative and absolute output paths. Add option to limit the number of files included in each output. Implement file content inclusion/exclusion options per output format.",
      "testStrategy": "1. Test generation of multiple output files with different formats\n2. Verify template variables are correctly substituted\n3. Test with various output path configurations (relative, absolute)\n4. Verify directory creation for output paths\n5. Test error handling when writing to invalid locations",
      "priority": "high",
      "dependencies": [
        4
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement Smart Context Window Management",
      "description": "Develop intelligent context window management to prioritize relevant files and optimize context size for AI systems.",
      "details": "Create a ContextWindowManager class to intelligently manage context size and relevance:\n\n```typescript\nexport interface ContextWindowOptions {\n  maxTokens?: number;\n  maxFiles?: number;\n  prioritizeActiveFile?: boolean;\n  prioritizePinnedTabs?: boolean;\n  tokensPerFile?: number;\n}\n\nexport class ContextWindowManager {\n  private options: ContextWindowOptions;\n  \n  constructor(options?: Partial<ContextWindowOptions>) {\n    this.options = {\n      maxTokens: options?.maxTokens || 8000, // Default token limit\n      maxFiles: options?.maxFiles || 20,\n      prioritizeActiveFile: options?.prioritizeActiveFile !== undefined ? \n        options.prioritizeActiveFile : true,\n      prioritizePinnedTabs: options?.prioritizePinnedTabs !== undefined ? \n        options.prioritizePinnedTabs : true,\n      tokensPerFile: options?.tokensPerFile || 400 // Approximate tokens per file\n    };\n  }\n  \n  public optimizeContext(files: FileData[], activeFile?: string, pinnedFiles?: string[]): FileData[] {\n    // Make a copy to avoid modifying the original\n    let optimizedFiles = [...files];\n    \n    // Sort files by priority\n    optimizedFiles.sort((a, b) => {\n      // Active file gets highest priority\n      if (this.options.prioritizeActiveFile && activeFile) {\n        if (a.filePath === activeFile) return -1;\n        if (b.filePath === activeFile) return 1;\n      }\n      \n      // Pinned tabs get next priority\n      if (this.options.prioritizePinnedTabs && pinnedFiles?.length) {\n        const aIsPinned = pinnedFiles.includes(a.filePath);\n        const bIsPinned = pinnedFiles.includes(b.filePath);\n        if (aIsPinned && !bIsPinned) return -1;\n        if (!aIsPinned && bIsPinned) return 1;\n      }\n      \n      // Default to alphabetical order\n      return a.filePath.localeCompare(b.filePath);\n    });\n    \n    // Limit by max files\n    if (this.options.maxFiles && optimizedFiles.length > this.options.maxFiles) {\n      optimizedFiles = optimizedFiles.slice(0, this.options.maxFiles);\n    }\n    \n    // Estimate token count and trim if needed\n    let totalTokens = 0;\n    const result: FileData[] = [];\n    \n    for (const file of optimizedFiles) {\n      // Rough estimate of tokens (characters / 4)\n      const fileTokens = Math.ceil(file.content.length / 4);\n      \n      if (totalTokens + fileTokens <= this.options.maxTokens!) {\n        result.push(file);\n        totalTokens += fileTokens;\n      } else if (result.length === 0) {\n        // Always include at least one file, but truncate content\n        const truncatedContent = file.content.substring(\n          0, \n          this.options.maxTokens! * 4\n        );\n        result.push({\n          filePath: file.filePath,\n          content: truncatedContent + '\\n// Content truncated due to size limits'\n        });\n        break;\n      } else {\n        // We've reached the token limit\n        break;\n      }\n    }\n    \n    return result;\n  }\n}\n```\n\nImplement token counting based on OpenAI's tokenization approach (approximately 4 characters per token). Add configuration options for maximum context size. Prioritize files based on relevance (active file, pinned tabs, recently edited). Support truncating large files to fit within context window. Add option to include file summaries instead of full content for large files.",
      "testStrategy": "1. Test file prioritization with various input scenarios\n2. Verify token counting and limiting works correctly\n3. Test with large files to ensure proper truncation\n4. Verify active file and pinned tabs are correctly prioritized\n5. Benchmark performance with large file sets",
      "priority": "medium",
      "dependencies": [
        5,
        6
      ],
      "status": "deferred",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Implement Direct AI API Integration",
      "description": "Add direct integration with popular AI APIs for seamless context sharing without requiring intermediate files.",
      "details": "Create an AIIntegrationManager to handle direct API integration with AI services:\n\n```typescript\nexport interface AIServiceConfig {\n  id: string;\n  name: string;\n  apiKey?: string;\n  endpoint?: string;\n  enabled: boolean;\n}\n\nexport class AIIntegrationManager {\n  private configManager: ConfigurationManager;\n  private logger: Logger;\n  private services: Map<string, AIServiceConfig> = new Map();\n  \n  constructor(configManager: ConfigurationManager, logger: Logger) {\n    this.configManager = configManager;\n    this.logger = logger;\n    this.loadServices();\n  }\n  \n  private loadServices(): void {\n    const config = this.configManager.getConfig();\n    // Load configured AI services\n    const aiServices = config.aiServices || [];\n    \n    for (const service of aiServices) {\n      this.services.set(service.id, service);\n    }\n  }\n  \n  public async sendContextToAI(files: FileData[]): Promise<void> {\n    for (const [id, service] of this.services.entries()) {\n      if (!service.enabled) continue;\n      \n      try {\n        switch (id) {\n          case 'openai':\n            await this.sendToOpenAI(files, service);\n            break;\n          case 'anthropic':\n            await this.sendToAnthropic(files, service);\n            break;\n          case 'cursor':\n            await this.sendToCursor(files, service);\n            break;\n          default:\n            this.logger.warn(`Unknown AI service: ${id}`);\n        }\n      } catch (error) {\n        this.logger.error(`Failed to send context to ${service.name}`, error as Error);\n      }\n    }\n  }\n  \n  private async sendToOpenAI(files: FileData[], config: AIServiceConfig): Promise<void> {\n    // Implementation for OpenAI API integration\n    // This would use the OpenAI API to store context\n  }\n  \n  private async sendToAnthropic(files: FileData[], config: AIServiceConfig): Promise<void> {\n    // Implementation for Anthropic API integration\n  }\n  \n  private async sendToCursor(files: FileData[], config: AIServiceConfig): Promise<void> {\n    // Implementation for Cursor API integration\n  }\n}\n```\n\nImplement integration with popular AI services including OpenAI, Anthropic, and Cursor. Use secure storage for API keys using VS Code's SecretStorage API. Add configuration options for API endpoints and authentication. Implement rate limiting and error handling for API requests. Add support for custom AI services through extension configuration.",
      "testStrategy": "1. Test API integration with mock servers\n2. Verify secure storage of API keys\n3. Test error handling for various API failure scenarios\n4. Verify rate limiting works correctly\n5. Test with actual AI services in a controlled environment",
      "priority": "low",
      "dependencies": [
        10,
        11
      ],
      "status": "deferred",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Implement Performance Analytics and Optimization",
      "description": "Add performance monitoring and analytics to identify bottlenecks and optimize extension performance.",
      "details": "Create a PerformanceMonitor class to track and analyze extension performance:\n\n```typescript\nexport interface PerformanceMetric {\n  operation: string;\n  duration: number;\n  timestamp: number;\n  metadata?: Record<string, any>;\n}\n\nexport class PerformanceMonitor {\n  private metrics: PerformanceMetric[] = [];\n  private logger: Logger;\n  private maxMetrics: number = 100;\n  \n  constructor(logger: Logger) {\n    this.logger = logger;\n  }\n  \n  public async trackOperation<T>(operation: string, fn: () => Promise<T>, metadata?: Record<string, any>): Promise<T> {\n    const startTime = performance.now();\n    try {\n      return await fn();\n    } finally {\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      \n      this.recordMetric({\n        operation,\n        duration,\n        timestamp: Date.now(),\n        metadata\n      });\n      \n      // Log slow operations\n      if (duration > 1000) { // More than 1 second\n        this.logger.warn(`Slow operation: ${operation} took ${duration.toFixed(2)}ms`, metadata);\n      }\n    }\n  }\n  \n  private recordMetric(metric: PerformanceMetric): void {\n    this.metrics.push(metric);\n    \n    // Keep metrics array from growing too large\n    if (this.metrics.length > this.maxMetrics) {\n      this.metrics = this.metrics.slice(-this.maxMetrics);\n    }\n  }\n  \n  public getMetrics(): PerformanceMetric[] {\n    return [...this.metrics];\n  }\n  \n  public getAverageMetrics(): Record<string, number> {\n    const operationTotals: Record<string, { total: number, count: number }> = {};\n    \n    for (const metric of this.metrics) {\n      if (!operationTotals[metric.operation]) {\n        operationTotals[metric.operation] = { total: 0, count: 0 };\n      }\n      \n      operationTotals[metric.operation].total += metric.duration;\n      operationTotals[metric.operation].count += 1;\n    }\n    \n    const averages: Record<string, number> = {};\n    for (const [operation, data] of Object.entries(operationTotals)) {\n      averages[operation] = data.total / data.count;\n    }\n    \n    return averages;\n  }\n  \n  public clearMetrics(): void {\n    this.metrics = [];\n  }\n}\n```\n\nImplement performance tracking for key operations including file reading, context generation, and output writing. Add memory usage monitoring to detect memory leaks. Create a performance dashboard command to view metrics. Implement automatic optimization suggestions based on performance data. Add telemetry for aggregate performance data (with user consent).",
      "testStrategy": "1. Test performance tracking with various operations\n2. Verify average metrics calculation is correct\n3. Test memory usage monitoring\n4. Benchmark performance with large workspaces\n5. Test performance dashboard command",
      "priority": "low",
      "dependencies": [
        6,
        7
      ],
      "status": "deferred",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "Implement Semantic File Prioritization",
      "description": "Develop semantic analysis capabilities to intelligently prioritize files based on content relevance to the current task.",
      "details": "Create a SemanticAnalyzer class to analyze file content and determine relevance:\n\n```typescript\nexport interface FileRelevanceScore {\n  filePath: string;\n  score: number;\n  reason: string;\n}\n\nexport class SemanticAnalyzer {\n  private activeFile?: string;\n  private activeFileContent?: string;\n  private stopwords: Set<string>;\n  \n  constructor() {\n    // Common programming stopwords\n    this.stopwords = new Set([\n      'the', 'and', 'a', 'to', 'of', 'is', 'in', 'that', 'it', 'with',\n      'for', 'as', 'be', 'this', 'on', 'not', 'or', 'by', 'at', 'from'\n    ]);\n  }\n  \n  public setActiveFile(filePath: string, content: string): void {\n    this.activeFile = filePath;\n    this.activeFileContent = content;\n  }\n  \n  public analyzeRelevance(files: FileData[]): FileRelevanceScore[] {\n    if (!this.activeFile || !this.activeFileContent) {\n      // Without an active file, we can't determine relevance\n      return files.map(file => ({\n        filePath: file.filePath,\n        score: 1, // Default score\n        reason: 'No active file for comparison'\n      }));\n    }\n    \n    // Extract keywords from active file\n    const activeKeywords = this.extractKeywords(this.activeFileContent);\n    \n    return files.map(file => {\n      // Skip the active file itself\n      if (file.filePath === this.activeFile) {\n        return {\n          filePath: file.filePath,\n          score: 10, // Highest score for active file\n          reason: 'Active file'\n        };\n      }\n      \n      // Calculate relevance based on keyword overlap\n      const fileKeywords = this.extractKeywords(file.content);\n      const commonKeywords = this.findCommonKeywords(activeKeywords, fileKeywords);\n      \n      // Calculate score based on common keywords and file path similarity\n      let score = commonKeywords.length / Math.max(1, activeKeywords.length) * 5;\n      \n      // Boost score for files in the same directory\n      if (path.dirname(file.filePath) === path.dirname(this.activeFile)) {\n        score += 2;\n      }\n      \n      // Boost score for files with similar names\n      const activeBasename = path.basename(this.activeFile, path.extname(this.activeFile));\n      const fileBasename = path.basename(file.filePath, path.extname(file.filePath));\n      if (fileBasename.includes(activeBasename) || activeBasename.includes(fileBasename)) {\n        score += 1;\n      }\n      \n      return {\n        filePath: file.filePath,\n        score,\n        reason: commonKeywords.length > 0 ? \n          `Common keywords: ${commonKeywords.slice(0, 5).join(', ')}` : \n          'No common keywords'\n      };\n    });\n  }\n  \n  private extractKeywords(content: string): string[] {\n    // Simple keyword extraction - split by non-alphanumeric chars and filter stopwords\n    const words = content.toLowerCase()\n      .split(/[^a-zA-Z0-9_]/) // Split by non-alphanumeric chars\n      .filter(word => word.length > 2) // Filter short words\n      .filter(word => !this.stopwords.has(word)); // Filter stopwords\n    \n    // Count word frequencies\n    const wordCounts = new Map<string, number>();\n    for (const word of words) {\n      wordCounts.set(word, (wordCounts.get(word) || 0) + 1);\n    }\n    \n    // Sort by frequency and return top keywords\n    return Array.from(wordCounts.entries())\n      .sort((a, b) => b[1] - a[1]) // Sort by frequency (descending)\n      .slice(0, 100) // Take top 100 keywords\n      .map(entry => entry[0]); // Extract just the words\n  }\n  \n  private findCommonKeywords(keywords1: string[], keywords2: string[]): string[] {\n    const set1 = new Set(keywords1);\n    return keywords2.filter(keyword => set1.has(keyword));\n  }\n}\n```\n\nImplement keyword extraction and frequency analysis to identify important terms in files. Add support for programming language-specific analysis (variable names, function calls, imports). Implement similarity scoring between files based on content overlap. Add support for directory structure analysis to identify related files. Integrate with the ContextWindowManager to prioritize semantically relevant files.",
      "testStrategy": "1. Test keyword extraction with various file types\n2. Verify relevance scoring with different file relationships\n3. Test with large codebases to ensure performance\n4. Verify language-specific analysis works correctly\n5. Test integration with context window management",
      "priority": "low",
      "dependencies": [
        11
      ],
      "status": "deferred",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "Implement Extension Packaging and Distribution",
      "description": "Prepare the extension for distribution through the VS Code Extension Marketplace, including documentation, packaging, and release management.",
      "details": "Set up the extension for packaging and distribution:\n\n1. Update package.json with required metadata:\n```json\n{\n  \"name\": \"auto-copilot-context\",\n  \"displayName\": \"Auto Copilot Context\",\n  \"description\": \"Automatically track and export the content of open files to provide AI systems with relevant context\",\n  \"version\": \"1.0.0\",\n  \"publisher\": \"your-publisher-id\",\n  \"engines\": {\n    \"vscode\": \"^1.84.0\"\n  },\n  \"categories\": [\n    \"Other\",\n    \"Programming Languages\",\n    \"Machine Learning\"\n  ],\n  \"keywords\": [\n    \"ai\",\n    \"copilot\",\n    \"context\",\n    \"automation\",\n    \"productivity\"\n  ],\n  \"activationEvents\": [\n    \"onStartupFinished\"\n  ],\n  \"main\": \"./dist/extension.js\",\n  \"contributes\": {\n    \"commands\": [\n      {\n        \"command\": \"autoCopilotContext.refreshContext\",\n        \"title\": \"Auto Copilot Context: Refresh Context\"\n      },\n      {\n        \"command\": \"autoCopilotContext.showLogs\",\n        \"title\": \"Auto Copilot Context: Show Logs\"\n      },\n      {\n        \"command\": \"autoCopilotContext.clearCache\",\n        \"title\": \"Auto Copilot Context: Clear Cache\"\n      },\n      {\n        \"command\": \"autoCopilotContext.toggle\",\n        \"title\": \"Auto Copilot Context: Toggle Extension\"\n      }\n    ],\n    \"configuration\": {\n      \"title\": \"Auto Copilot Context\",\n      \"properties\": {\n        \"autoCopilotContext.enabled\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"Enable or disable the extension\"\n        },\n        \"autoCopilotContext.outputPaths\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"string\"\n          },\n          \"default\": [\".vscode/copilot-context.json\"],\n          \"description\": \"Paths to output context files\"\n        },\n        // Additional configuration properties\n      }\n    }\n  },\n  \"scripts\": {\n    \"vscode:prepublish\": \"npm run package\",\n    \"compile\": \"webpack\",\n    \"watch\": \"webpack --watch\",\n    \"package\": \"webpack --mode production --devtool hidden-source-map\",\n    \"test\": \"mocha -r ts-node/register src/**/*.test.ts\"\n  },\n  \"devDependencies\": {\n    \"@types/mocha\": \"^10.0.1\",\n    \"@types/node\": \"^18.15.11\",\n    \"@types/vscode\": \"^1.84.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^5.59.0\",\n    \"@typescript-eslint/parser\": \"^5.59.0\",\n    \"eslint\": \"^8.38.0\",\n    \"mocha\": \"^10.2.0\",\n    \"ts-loader\": \"^9.4.2\",\n    \"ts-node\": \"^10.9.1\",\n    \"typescript\": \"^5.0.4\",\n    \"webpack\": \"^5.79.0\",\n    \"webpack-cli\": \"^5.0.1\"\n  },\n  \"dependencies\": {\n    \"ignore\": \"^5.2.4\",\n    \"minimatch\": \"^5.1.0\"\n  }\n}\n```\n\n2. Create a comprehensive README.md with installation and usage instructions\n3. Set up GitHub Actions for CI/CD:\n```yaml\nname: CI/CD\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16.x'\n    - run: npm ci\n    - run: npm run compile\n    - run: npm test\n\n  publish:\n    needs: build\n    if: startsWith(github.ref, 'refs/tags/v')\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - name: Use Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '16.x'\n    - run: npm ci\n    - run: npm run package\n    - name: Publish to VS Code Marketplace\n      uses: HaaLeo/publish-vscode-extension@v1\n      with:\n        pat: ${{ secrets.VSCE_PAT }}\n        registryUrl: https://marketplace.visualstudio.com\n```\n\n4. Set up webpack.config.js for bundling:\n```javascript\nconst path = require('path');\n\nmodule.exports = {\n  target: 'node',\n  mode: 'none',\n  entry: './src/extension.ts',\n  output: {\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'extension.js',\n    libraryTarget: 'commonjs2'\n  },\n  externals: {\n    vscode: 'commonjs vscode'\n  },\n  resolve: {\n    extensions: ['.ts', '.js']\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.ts$/,\n        exclude: /node_modules/,\n        use: [\n          {\n            loader: 'ts-loader'\n          }\n        ]\n      }\n    ]\n  }\n};\n```\n\n5. Create CHANGELOG.md to track version changes\n6. Set up .vscodeignore to exclude unnecessary files from the package\n7. Create a LICENSE file (MIT recommended)\n8. Set up semantic versioning for releases",
      "testStrategy": "1. Verify extension packaging with vsce package command\n2. Test installation from VSIX file\n3. Verify all commands are registered correctly\n4. Test extension in different VS Code versions\n5. Verify documentation accuracy and completeness",
      "priority": "medium",
      "dependencies": [
        1,
        2,
        3,
        4,
        5,
        7,
        8
      ],
      "status": "deferred",
      "subtasks": []
    },
    {
      "id": 16,
      "title": "实现多工作区输出支持",
      "description": "扩展当前的 auto context 插件，支持在 VS Code 多工作区环境下将上下文输出到不同的工作区目录中。",
      "details": "当前插件只能输出到单一的 workspacePath，需要新增配置和功能来支持 code-workspace 文件中定义的多个 folders。\n\n核心需求：\n1. 读取 VS Code workspace 配置中的 folders 数组\n2. 支持将上下文输出到每个 folder 目录中\n3. 扩展现有的 outputList 配置，支持相对路径解析到不同工作区\n4. 保持向后兼容性\n\n技术实现要点：\n\n1. 使用 vscode.workspace.workspaceFolders API：\n```typescript\ninterface WorkspaceOutputConfig extends OutputConfig {\n  targetWorkspaces?: string[]; // 指定输出到哪些工作区，空则输出到所有\n  useWorkspaceRelativePath?: boolean; // 是否使用相对于工作区的路径\n}\n\nclass MultiWorkspaceContextTracker extends ContextTracker {\n  private getWorkspaceFolders(): vscode.WorkspaceFolder[] {\n    return vscode.workspace.workspaceFolders || [];\n  }\n  \n  private resolveOutputPaths(config: WorkspaceOutputConfig): string[] {\n    const workspaceFolders = this.getWorkspaceFolders();\n    const outputPaths: string[] = [];\n    \n    for (const folder of workspaceFolders) {\n      // 检查是否应该输出到这个工作区\n      if (config.targetWorkspaces && \n          !config.targetWorkspaces.includes(folder.name)) {\n        continue;\n      }\n      \n      let outputPath: string;\n      if (config.useWorkspaceRelativePath) {\n        outputPath = path.join(folder.uri.fsPath, config.path);\n      } else {\n        outputPath = path.isAbsolute(config.path) ? \n          config.path : \n          path.join(folder.uri.fsPath, config.path);\n      }\n      \n      outputPaths.push(outputPath);\n    }\n    \n    return outputPaths;\n  }\n}\n```\n\n2. 扩展配置选项：\n```typescript\ninterface ExtensionConfig {\n  outputList: WorkspaceOutputConfig[];\n  shouldOutput: boolean;\n  ignorePinnedTabs: boolean;\n  multiWorkspaceMode: boolean; // 新增：启用多工作区模式\n  defaultWorkspaceOutput: boolean; // 新增：是否在所有工作区输出\n}\n```\n\n3. 修改文件写入逻辑：\n```typescript\nprivate writeOutput(files: FileData[]): void {\n  try {\n    this.outputList.forEach(outputConfig => {\n      const outputPaths = this.resolveOutputPaths(outputConfig);\n      \n      outputPaths.forEach(outputPath => {\n        const formattedOutput = this.formatOutput(files, outputConfig.format);\n        const finalOutput = outputConfig.prependContent ? \n          `${outputConfig.prependContent}\\n${formattedOutput}` : \n          formattedOutput;\n        \n        const outputDir = path.dirname(outputPath);\n        if (!fs.existsSync(outputDir)) {\n          fs.mkdirSync(outputDir, { recursive: true });\n        }\n\n        fs.writeFileSync(outputPath, finalOutput, 'utf8');\n      });\n    });\n  } catch (error) {\n    this.handleError('Failed to write output files', error);\n  }\n}\n```\n\n4. 新增配置示例：\n```json\n{\n  \"autoContext.multiWorkspaceMode\": true,\n  \"autoContext.outputList\": [\n    {\n      \"path\": \"output/context.xml\",\n      \"format\": \"<Opened Files>\\n<File Name>\\n${fileName}\\n</File Name>\\n<File Content>\\n${content}\\n</File Content>\\n</Opened Files>\\n\",\n      \"prependContent\": \"\",\n      \"targetWorkspaces\": [\"auto-copilot-context\", \"llm-prompts\"],\n      \"useWorkspaceRelativePath\": true\n    },\n    {\n      \"path\": \".cursor/rules/context.mdc\",\n      \"format\": \"<Opened Files>\\n<File Name>\\n${fileName}\\n</File Name>\\n<File Content>\\n${content}\\n</File Content>\\n</Opened Files>\\n\",\n      \"prependContent\": \"---\\ndescription: \\nglobs: \\nalwaysApply: true\\n---\",\n      \"useWorkspaceRelativePath\": true\n    }\n  ]\n}\n```\n\n5. 文件路径处理：\n- 支持绝对路径和相对路径\n- 相对路径相对于每个工作区根目录解析\n- 添加工作区名称过滤功能\n- 支持通配符匹配工作区名称",
      "testStrategy": "1. 测试单工作区环境下的向后兼容性\n2. 测试多工作区环境下的路径解析\n3. 验证文件输出到正确的工作区目录\n4. 测试工作区名称过滤功能\n5. 验证配置更新时的实时响应\n6. 测试边界情况（空工作区、无权限目录等）",
      "priority": "high",
      "dependencies": [
        2,
        4,
        10
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "实现多工作区输出逻辑",
          "description": "修改 writeOutput 方法支持检测多工作区环境并输出到所有工作区目录",
          "details": "- 使用 vscode.workspace.workspaceFolders 检测多工作区\n- 在多工作区环境下遍历所有文件夹并输出\n- 保持单工作区环境的向后兼容性\n- 添加错误隔离机制",
          "status": "done",
          "dependencies": [
            "16.4"
          ],
          "parentTaskId": 16
        },
        {
          "id": 2,
          "title": "实现文件跟踪和清理功能",
          "description": "添加输出文件跟踪机制，并在窗口关闭时自动清理文件",
          "details": "- 添加 outputFiles Set 来跟踪所有输出文件\n- 监听窗口关闭事件\n- 实现 cleanupOutputFiles 方法删除跟踪的文件\n- 在 dispose 方法中确保文件清理",
          "status": "done",
          "dependencies": [
            "16.1"
          ],
          "parentTaskId": 16
        },
        {
          "id": 3,
          "title": "添加测试用例",
          "description": "为多工作区输出和文件清理功能添加全面的测试用例",
          "details": "- 单工作区兼容性测试\n- 多工作区功能测试\n- 文件清理测试\n- 错误处理测试\n- 边界情况测试",
          "status": "done",
          "dependencies": [
            "16.2"
          ],
          "parentTaskId": 16
        },
        {
          "id": 4,
          "title": "抽象writeOutput为独立模块",
          "description": "将ContextTracker中的writeOutput逻辑抽象为独立的OutputWriter模块，提高代码可维护性和可测试性",
          "details": "- 创建新的OutputWriter类负责文件输出逻辑\n- 将writeOutput相关代码从ContextTracker中分离\n- 设计清晰的接口用于依赖注入\n- 保持现有功能不变，只进行代码重构\n- 为后续多工作区功能扩展做准备",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 16
        }
      ]
    },
    {
      "id": 17,
      "title": "重构 ContextTracker 实现单一职责原则",
      "description": "重构 ContextTracker 类已完成，拆分为多个专门的类，实现了单一职责原则。现在需要添加单元测试并进行功能验证。",
      "status": "in-progress",
      "dependencies": [
        1,
        2,
        3,
        4,
        7
      ],
      "priority": "high",
      "details": "重构第一阶段（代码拆分）已完成，具体成果如下：\n\n- 目录结构已调整：\n  ```\n  src/\n    ├── types/\n    │   └── interfaces.ts   # 定义所有接口\n    ├── core/\n    │   ├── ContextTracker.ts\n    │   ├── FileCollector.ts\n    │   └── ... \n    ├── services/\n    │   ├── FileFilter.ts\n    │   ├── OutputFormatter.ts\n    │   └── ...\n    ├── utils/\n    │   ├── logger.ts\n    │   ├── errorHandler.ts\n    │   └── ...\n    └── extension.ts\n  ```\n\n- 成功拆分原始类：\n  - ConfigurationManager - 配置管理\n  - FileFilter - 文件过滤（包含gitignore支持）\n  - FileCollector - 收集打开的文件\n  - OutputFormatter - 格式化输出\n  - ErrorHandler - 错误处理\n  - ContextTracker - 作为协调器\n\n- 功能完整性：所有原有功能保留，无新增功能，编译无错误\n\n- 实现单一职责原则：\n  - 每个类职责单一\n  - 使用依赖注入模式\n  - 接口定义清晰（位于src/types/interfaces.ts）\n\n重构成果：\n- 197行单一文件拆分为6个专门类\n- 代码可维护性大幅提升\n- 为单元测试奠定基础\n\n下一步：\n1. 添加单元测试覆盖\n2. 进行功能验证测试\n3. 考虑性能优化机会",
      "testStrategy": "1. 单元测试：\n   - 为每个新创建的类编写单元测试，确保它们独立工作正常：\n   ```typescript\n   // FileCollector.test.ts\n   describe('FileCollector', () => {\n     let fileCollector: FileCollector;\n     let mockWorkspace: vscode.WorkspaceFolder;\n     \n     beforeEach(() => {\n       mockWorkspace = { uri: { fsPath: '/test/path' } } as vscode.WorkspaceFolder;\n       fileCollector = new FileCollector(mockWorkspace);\n     });\n     \n     test('getOpenFiles should return only files from current workspace', async () => {\n       // 模拟 vscode.workspace.textDocuments\n       // 验证过滤逻辑\n     });\n     \n     // 更多测试...\n   });\n   ```\n\n2. 集成测试：\n   - 测试重构后的 ContextTracker 与其他组件的集成：\n   ```typescript\n   describe('ContextTracker Integration', () => {\n     let contextTracker: ContextTracker;\n     let mockConfigManager: ConfigurationManager;\n     \n     beforeEach(() => {\n       // 设置测试环境\n     });\n     \n     test('updateContext should collect, filter and format files correctly', async () => {\n       // 验证完整流程\n     });\n   });\n   ```\n\n3. 手动测试：\n   - 验证重构后功能一致性：\n     - 打开多个文件，验证文件收集功能\n     - 测试不同的过滤配置（包括gitignore）\n     - 验证输出格式是否正确\n     - 测试错误场景（如权限问题、无效配置等）\n\n4. 性能测试：\n   - 测量重构后性能：\n   ```typescript\n   test('performance measurement', async () => {\n     const startTime = performance.now();\n     await contextTracker.updateContext();\n     const endTime = performance.now();\n     \n     console.log(`Execution time: ${endTime - startTime}ms`);\n   });\n   ```\n\n5. 代码覆盖率检查：\n   - 使用测试框架覆盖率工具确保新代码足够覆盖\n   - 目标覆盖率：行覆盖率 > 80%，分支覆盖率 > 70%\n\n6. 回归测试：\n   - 确保现有功能在重构后仍然正常工作",
      "subtasks": [
        {
          "id": 1,
          "title": "创建新的目录结构",
          "description": "已创建 src/types/interfaces.ts, src/services/, src/core/, src/utils/ 目录结构",
          "status": "done"
        },
        {
          "id": 2,
          "title": "拆分 ContextTracker 类",
          "description": "已拆分为 ConfigurationManager, FileFilter, FileCollector, OutputFormatter, ErrorHandler 和协调器 ContextTracker",
          "status": "done"
        },
        {
          "id": 3,
          "title": "保持功能完整性",
          "description": "所有原有功能保留，无新增功能，编译无错误",
          "status": "done"
        },
        {
          "id": 4,
          "title": "实现单一职责原则",
          "description": "每个类职责单一，使用依赖注入，接口定义清晰",
          "status": "done"
        },
        {
          "id": 5,
          "title": "添加单元测试覆盖",
          "description": "为 FileCollector, FileFilter, OutputFormatter 等新类编写单元测试",
          "status": "todo"
        },
        {
          "id": 6,
          "title": "进行功能验证测试",
          "description": "手动测试验证重构后功能一致性",
          "status": "todo"
        },
        {
          "id": 7,
          "title": "性能优化分析",
          "description": "识别并实现可能的性能优化点",
          "status": "todo"
        }
      ]
    },
    {
      "id": 18,
      "title": "实现单元测试框架和测试用例",
      "description": "为插件核心组件设计并实现一套完整的单元测试方案，覆盖ConfigurationManager、ContextTracker和extension.ts中的关键功能，确保代码质量和可靠性。",
      "status": "in-progress",
      "dependencies": [
        2,
        17
      ],
      "priority": "high",
      "details": "本任务将为插件核心组件实现全面的单元测试框架和测试用例：\n\n1. 测试环境搭建：\n   - 安装必要的测试依赖：\n   ```bash\n   npm install --save-dev mocha @types/mocha chai @types/chai sinon @types/sinon @vscode/test-electron\n   ```\n   - 在`package.json`中配置测试脚本：\n   ```json\n   \"scripts\": {\n     \"test\": \"node ./out/test/runTest.js\"\n   }\n   ```\n   - 创建测试目录结构：\n   ```\n   src/\n     ├── test/\n     │   ├── suite/\n     │   │   ├── configurationManager.test.ts\n     │   │   ├── contextTracker.test.ts\n     │   │   ├── extension.test.ts\n     │   │   └── index.ts\n     │   ├── runTest.ts\n     │   ├── testUtils.ts\n     │   └── testConfig.ts\n   ```\n\n2. ConfigurationManager 测试实现：\n   ```typescript\n   // configurationManager.test.ts\n   import * as assert from 'assert';\n   import * as sinon from 'sinon';\n   import * as vscode from 'vscode';\n   import { ConfigurationManager } from '../../core/ConfigurationManager';\n   \n   suite('ConfigurationManager Tests', () => {\n     let configManager: ConfigurationManager;\n     let mockWorkspace: sinon.SinonStub;\n     \n     setup(() => {\n       // 模拟 vscode.workspace.getConfiguration\n       mockWorkspace = sinon.stub(vscode.workspace, 'getConfiguration');\n       mockWorkspace.returns({\n         get: (key: string) => {\n           if (key === 'outputPaths') return ['./context'];\n           if (key === 'enableGitignore') return true;\n           // 其他配置项...\n           return undefined;\n         },\n         update: sinon.stub().resolves()\n       });\n       \n       configManager = new ConfigurationManager();\n     });\n     \n     teardown(() => {\n       mockWorkspace.restore();\n     });\n     \n     test('should load default configuration correctly', () => {\n       const config = configManager.getConfig();\n       assert.strictEqual(config.outputPaths[0], './context');\n       assert.strictEqual(config.enableGitignore, true);\n     });\n     \n     test('should detect configuration changes', async () => {\n       const onConfigChangedSpy = sinon.spy();\n       configManager.onConfigChanged(onConfigChangedSpy);\n       \n       // 触发配置变更事件\n       const changeEvent = {\n         affectsConfiguration: (section: string) => section === 'autoContext'\n       };\n       await vscode.workspace.onDidChangeConfiguration.fire(changeEvent);\n       \n       assert.strictEqual(onConfigChangedSpy.calledOnce, true);\n     });\n     \n     // 更多测试用例...\n   });\n   ```\n\n3. ContextTracker 测试实现：\n   ```typescript\n   // contextTracker.test.ts\n   import * as assert from 'assert';\n   import * as sinon from 'sinon';\n   import * as vscode from 'vscode';\n   import { ContextTracker } from '../../core/ContextTracker';\n   import { ConfigurationManager } from '../../core/ConfigurationManager';\n   import { FileCollector } from '../../core/FileCollector';\n   \n   suite('ContextTracker Tests', () => {\n     let contextTracker: ContextTracker;\n     let mockConfigManager: sinon.SinonStubbedInstance<ConfigurationManager>;\n     let mockFileCollector: sinon.SinonStubbedInstance<FileCollector>;\n     \n     setup(() => {\n       // 创建模拟依赖\n       mockConfigManager = sinon.createStubInstance(ConfigurationManager);\n       mockFileCollector = sinon.createStubInstance(FileCollector);\n       \n       // 初始化 ContextTracker\n       contextTracker = new ContextTracker(\n         mockConfigManager as unknown as ConfigurationManager,\n         mockFileCollector as unknown as FileCollector\n       );\n     });\n     \n     test('should initialize correctly', () => {\n       assert.ok(contextTracker);\n       // 验证初始化时调用了正确的方法\n       assert.strictEqual(mockConfigManager.getConfig.calledOnce, true);\n     });\n     \n     test('should handle file changes correctly', async () => {\n       // 模拟文件变更事件\n       const fileUri = vscode.Uri.file('/test/path/file.ts');\n       const fileChangeEvent = { uri: fileUri };\n       \n       // 触发文件变更\n       await contextTracker.handleFileChange(fileChangeEvent);\n       \n       // 验证是否调用了文件收集器的更新方法\n       assert.strictEqual(mockFileCollector.updateFile.calledOnce, true);\n       assert.strictEqual(mockFileCollector.updateFile.firstCall.args[0], fileUri);\n     });\n     \n     test('should dispose resources correctly', () => {\n       const disposableSpy = sinon.spy();\n       (contextTracker as any).disposables = [{ dispose: disposableSpy }];\n       \n       contextTracker.dispose();\n       \n       assert.strictEqual(disposableSpy.calledOnce, true);\n     });\n     \n     // 更多测试用例...\n   });\n   ```\n\n4. Extension 激活测试：\n   ```typescript\n   // extension.test.ts\n   import * as assert from 'assert';\n   import * as sinon from 'sinon';\n   import * as vscode from 'vscode';\n   import * as myExtension from '../../extension';\n   \n   suite('Extension Activation Tests', () => {\n     test('should register all commands when activated', async () => {\n       // 模拟 vscode.commands.registerCommand\n       const registerCommandStub = sinon.stub(vscode.commands, 'registerCommand').returns({\n         dispose: () => {}\n       });\n       \n       // 激活扩展\n       const context: vscode.ExtensionContext = {\n         subscriptions: [],\n         // 其他必要的上下文属性...\n       } as any;\n       \n       await myExtension.activate(context);\n       \n       // 验证命令注册\n       assert.strictEqual(registerCommandStub.called, true);\n       assert.ok(registerCommandStub.calledWith('autoContext.generateContext'));\n       \n       // 验证上下文订阅\n       assert.ok(context.subscriptions.length > 0);\n       \n       registerCommandStub.restore();\n     });\n     \n     test('should initialize core components correctly', async () => {\n       // 使用 spy 监视核心组件的初始化\n       const contextTrackerSpy = sinon.spy(global, 'ContextTracker');\n       const configManagerSpy = sinon.spy(global, 'ConfigurationManager');\n       \n       const context: vscode.ExtensionContext = {\n         subscriptions: [],\n         // 其他必要的上下文属性...\n       } as any;\n       \n       await myExtension.activate(context);\n       \n       // 验证核心组件初始化\n       assert.strictEqual(configManagerSpy.calledOnce, true);\n       assert.strictEqual(contextTrackerSpy.calledOnce, true);\n       \n       contextTrackerSpy.restore();\n       configManagerSpy.restore();\n     });\n   });\n   ```\n\n5. 测试运行器实现：\n   ```typescript\n   // runTest.ts\n   import * as path from 'path';\n   import { runTests } from '@vscode/test-electron';\n   import { config } from './testConfig';\n\n   async function main() {\n     try {\n       const extensionDevelopmentPath = path.resolve(__dirname, '../../');\n       const extensionTestsPath = path.resolve(__dirname, './suite/index');\n\n       await runTests({\n         extensionDevelopmentPath,\n         extensionTestsPath,\n         launchArgs: [\n           '--disable-extensions',\n           '--disable-workspace-trust'\n         ],\n         version: config.vscodeVersion,\n         extensionTestsEnv: {\n           TEST_VERBOSE: config.verbose ? 'true' : 'false',\n           MOCHA_TIMEOUT: config.timeout.toString()\n         }\n       });\n     } catch (err) {\n       console.error('Failed to run tests:', err);\n       process.exit(1);\n     }\n   }\n\n   main();\n   ```\n\n6. 测试配置系统：\n   ```typescript\n   // testConfig.ts\n   export const config = {\n     vscodeVersion: process.env.VSCODE_VERSION || 'stable',\n     verbose: process.env.TEST_VERBOSE === 'true',\n     timeout: parseInt(process.env.TEST_TIMEOUT || '5000'),\n     mochaOptions: {\n       ui: 'tdd',\n       color: true,\n       timeout: parseInt(process.env.TEST_TIMEOUT || '5000')\n     }\n   };\n   ```\n\n7. 测试套件入口：\n   ```typescript\n   // index.ts\n   import * as path from 'path';\n   import * as Mocha from 'mocha';\n   import * as glob from 'glob';\n   import { config } from '../testConfig';\n\n   export function run(): Promise<void> {\n     const mocha = new Mocha(config.mochaOptions);\n\n     const testsRoot = path.resolve(__dirname, '.');\n\n     return new Promise((resolve, reject) => {\n       glob('**/**.test.js', { cwd: testsRoot }, (err, files) => {\n         if (err) {\n           return reject(err);\n         }\n\n         files.forEach(f => mocha.addFile(path.resolve(testsRoot, f)));\n\n         try {\n           mocha.run(failures => {\n             if (failures > 0) {\n               reject(new Error(`${failures} tests failed.`));\n             } else {\n               resolve();\n             }\n           });\n         } catch (err) {\n           reject(err);\n         }\n       });\n     });\n   }\n   ```\n\n8. 测试工具类增强：\n   ```typescript\n   // testUtils.ts\n   import * as vscode from 'vscode';\n   import * as sinon from 'sinon';\n\n   // 现有函数...\n   \n   // 新增增强功能\n   export function createMockTextEditor(\n     document: vscode.TextDocument,\n     selections: vscode.Selection[] = [new vscode.Selection(0, 0, 0, 0)]\n   ): vscode.TextEditor {\n     return {\n       document,\n       selection: selections[0],\n       selections,\n       visibleRanges: [new vscode.Range(0, 0, document.lineCount, 0)],\n       viewColumn: vscode.ViewColumn.One,\n       // 其他必要属性和方法...\n     } as any;\n   }\n\n   export function assertCalled(spy: sinon.SinonSpy, callCount = 1, message?: string) {\n     if (spy.callCount !== callCount) {\n       throw new Error(message || `Expected ${callCount} calls, got ${spy.callCount}`);\n     }\n   }\n\n   export function sleep(ms: number): Promise<void> {\n     return new Promise(resolve => setTimeout(resolve, ms));\n   }\n\n   export function createTempWorkspaceFolder(): vscode.WorkspaceFolder {\n     const tempPath = require('os').tmpdir();\n     const folderName = `test-workspace-${Date.now()}`;\n     const folderPath = path.join(tempPath, folderName);\n     \n     return {\n       name: folderName,\n       uri: vscode.Uri.file(folderPath),\n       index: 0\n     };\n   }\n   ```",
      "testStrategy": "测试策略将采用以下步骤验证实现的正确性：\n\n1. 单元测试验证：\n   - 运行所有单元测试并确保通过率达到 90% 以上：\n   ```bash\n   # 使用环境变量配置测试\n   TEST_VERBOSE=true VSCODE_VERSION=1.85.0 TEST_TIMEOUT=15000 npm test\n   ```\n   \n   - 使用 NYC 或 Istanbul 生成代码覆盖率报告，验证关键模块的覆盖率：\n   ```bash\n   npm install --save-dev nyc\n   npx nyc npm run test\n   ```\n   \n   - 检查覆盖率报告，确保：\n     * ConfigurationManager: 行覆盖率 > 90%\n     * ContextTracker: 行覆盖率 > 85%\n     * extension.ts activate 函数: 行覆盖率 > 80%\n\n2. 模块功能验证：\n   - ConfigurationManager 测试验证点：\n     * 默认配置加载正确\n     * 配置更新能被正确检测\n     * 配置验证逻辑工作正常\n     * 配置变更事件正确触发\n     * 无效配置能被正确处理\n\n   - ContextTracker 测试验证点：\n     * 初始化过程正确创建所需资源\n     * 文件变更事件能被正确处理\n     * 资源释放（dispose）逻辑正确执行\n     * 与其他组件的交互符合预期\n\n   - extension.ts 测试验证点：\n     * 扩展激活时正确初始化所有组件\n     * 命令注册成功\n     * 事件订阅正确设置\n     * 扩展上下文正确配置\n\n3. 集成测试验证：\n   - 使用@vscode/test-electron创建模拟VS Code环境\n   - 验证完整工作流程：\n     * 扩展激活\n     * 配置加载\n     * 文件变更触发上下文更新\n     * 输出生成\n   - 测试不同配置组合下的行为\n   - 使用环境变量控制测试参数：\n     ```bash\n     # 过滤特定测试\n     MOCHA_GREP=\"ConfigurationManager\" npm test\n     ```\n\n4. 边缘情况测试：\n   - 测试无效配置情况下的行为\n   - 测试大量文件变更时的性能和稳定性\n   - 测试在资源受限环境下的行为\n\n5. 回归测试：\n   - 确保所有之前实现的功能在添加测试后仍然正常工作\n   - 验证与其他 VS Code 功能的兼容性未受影响\n\n6. 手动验证：\n   - 在实际 VS Code 环境中运行测试版本\n   - 验证扩展在实际使用场景中的行为符合预期\n   - 确认测试覆盖了所有关键用户场景\n\n测试通过标准：\n- 所有自动化测试通过\n- 代码覆盖率达到目标阈值\n- 手动验证未发现功能缺陷\n- 性能指标符合预期",
      "subtasks": [
        {
          "id": 1,
          "title": "Test Environment Setup and Dependency Installation",
          "description": "Set up the testing environment and install required dependencies",
          "dependencies": [],
          "details": "1. Install testing dependencies: mocha, chai, sinon, and vscode test-electron packages. 2. Configure test script in package.json to point to the test runner. 3. Create the test directory structure with files for ConfigurationManager, ContextTracker, and extension tests.\n<info added on 2025-06-07T05:29:09.926Z>\nImplemented test utility functions in src/test/testUtils.ts:\n- createMockTextDocument(): Mocks a VS Code TextDocument\n- createMockWorkspaceFolder(): Mocks a VS Code WorkspaceFolder\n- createMockExtensionContext(): Mocks the vscode.ExtensionContext\n- createMockConfiguration(): Mocks a vscode.WorkspaceConfiguration\n- setupVSCodeMocks(): Sets up global mocks for VS Code API\n\nVerified test directory structure includes testUtils.ts and all test scripts. Confirmed successful test execution through compilation, linting, and test runner validation. Testing environment is fully operational with all dependencies installed and configured.\n</info added on 2025-06-07T05:29:09.926Z>",
          "status": "done",
          "testStrategy": "Verify installation via npm list command and validate directory structure exists"
        },
        {
          "id": 2,
          "title": "Implement Test Utility Functions",
          "description": "Create reusable test utility functions for mocking VS Code components",
          "dependencies": [
            1
          ],
          "details": "Implement testUtils.ts with helper functions: 1. createMockTextDocument for simulating text documents. 2. createMockWorkspaceFolder for workspace simulation. 3. Include type-safe mocks for VS Code API methods used in tests.\n<info added on 2025-06-07T05:30:24.336Z>\nNote: Implementation of the test utility functions was completed in subtask 18.1. The following functions are now available in src/test/testUtils.ts:\n\n1. createMockTextDocument(content: string, fileName: string)\n   - Creates a mock VS Code TextDocument object with complete document properties: fileName, getText(), uri, lineCount, lineAt()\n   - Supports TypeScript language ID and version control\n   - Includes all necessary method stubs\n\n2. createMockWorkspaceFolder(name: string, path: string)\n   - Creates a mock WorkspaceFolder object with name, uri, and index properties\n   - Used for simulating multi-workspace environments\n\n3. createMockExtensionContext()\n   - Creates a complete mock ExtensionContext object\n   - Includes subscriptions array for resource management\n   - Mocks workspaceState and globalState\n   - Includes secrets API mock\n   - Supports environment variables collection\n   - Includes storage paths and extension information\n\n4. createMockConfiguration(configValues: Record<string, any>)\n   - Creates a mock WorkspaceConfiguration object\n   - Supports get(), has(), inspect(), and update() methods\n   - Allows preset configuration values for testing\n\n5. setupVSCodeMocks()\n   - Sets up global VS Code API mocks\n   - Mocks workspace.getConfiguration\n   - Mocks window message APIs (showErrorMessage, showInformationMessage, showWarningMessage)\n   - Mocks commands.registerCommand\n   - Returns cleanup function for test restoration\n\nAll functions include complete TypeScript type support and use sinon for method mocking, providing robust infrastructure for unit tests.\n</info added on 2025-06-07T05:30:24.336Z>",
          "status": "done",
          "testStrategy": "Unit test utility functions by verifying they return correctly structured mock objects"
        },
        {
          "id": 3,
          "title": "Implement ConfigurationManager Unit Tests",
          "description": "Create test cases for ConfigurationManager functionality",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Implement configurationManager.test.ts with test suite. 2. Test configuration loading with default values. 3. Test configuration change detection mechanism. 4. Verify update method behavior using sinon stubs. 5. Cover all configuration properties and edge cases.\n<info added on 2025-06-07T05:54:16.387Z>\nTests implemented and passed:\n- should load default configuration when no outputList is configured\n- should load custom outputList configuration\n- should handle missing workspace root path\n- should convert relative paths to absolute paths\n- should preserve absolute paths\n- should handle boolean configuration values correctly\n- should use correct configuration section\n\nTest results: 8 tests passed in 7ms with no compilation or linting errors. Coverage includes all core functionality: configuration loading, path handling, default values, and error cases.\n</info added on 2025-06-07T05:54:16.387Z>",
          "status": "done",
          "testStrategy": "Mocha/Chai tests with sinon for mocking, verify all assertions pass"
        },
        {
          "id": 4,
          "title": "Implement ContextTracker Unit Tests",
          "description": "Create test cases for ContextTracker functionality",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Implement contextTracker.test.ts test suite. 2. Test initialization dependencies. 3. Verify file change handling logic. 4. Test resource disposal mechanism. 5. Cover interaction with FileCollector using stubs.\n<info added on 2025-06-07T07:16:52.691Z>\n1. Implement ContextTracker unit tests in contextTracker.test.ts using @vscode/test-electron framework with sinon for stubs/spies\n2. Test initialization with configuration dependencies and method validation\n3. Verify file change event handling logic and listener setup\n4. Test open file tracking through textDocuments and tabGroups simulation\n5. Cover resource disposal mechanism and disposable cleanup\n6. Validate error handling during output operations\n7. Implement document validation checks for scheme and untitled files\n8. Utilize testUtils for mock context/config and setup/teardown patterns\n9. Verification points: initialization, event listeners, file collection, disposal, error handling\n</info added on 2025-06-07T07:16:52.691Z>",
          "status": "pending",
          "testStrategy": "Mocha/Chai tests with sinon spies/stubs, validate mock interactions"
        },
        {
          "id": 5,
          "title": "Implement Extension Activation Tests",
          "description": "Create tests for extension activation and command registration",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Implement extension.test.ts test suite. 2. Test command registration during activation. 3. Verify core component initialization. 4. Test subscription management in extension context. 5. Cover error handling during activation.\n<info added on 2025-06-07T07:18:13.895Z>\n1. Implement extension.test.ts test suite using @vscode/test-electron framework  \n2. Test command registration during activation with focus on 'auto-context.removeTopCommentBlocks'  \n3. Verify ContextTracker initialization and subscription management  \n4. Test graceful handling of missing workspace during activation  \n5. Validate configuration loading during activation  \n6. Cover error handling scenarios including configuration errors  \n7. Implement resource disposal verification on deactivation  \n8. Include tests for extension activation success verification  \n9. Ensure test coverage for configuration loading and error handling  \n10. Follow TDD structure with setup/teardown patterns using sinon for API mocking\n</info added on 2025-06-07T07:18:13.895Z>",
          "status": "pending",
          "testStrategy": "Mocha tests with sinon to spy on VS Code command registration"
        },
        {
          "id": 6,
          "title": "Implement Test Runner and Suite Integration",
          "description": "Set up test runner and test suite entry point",
          "dependencies": [
            1
          ],
          "details": "1. Implement runTest.ts to launch VS Code test environment. 2. Create index.ts as test suite entry. 3. Configure Mocha instance with TDD interface. 4. Implement glob-based test discovery. 5. Set up proper error handling and exit codes.\n<info added on 2025-06-07T05:55:17.894Z>\n测试运行器和套件集成已完成验证，所有组件均正常工作：\n\n✅ runTest.ts (src/test/runTest.ts)已正确配置，成功启动VS Code测试环境，正确设置路径和错误处理\n\n✅ index.ts (src/test/suite/index.ts)已正确配置为测试套件入口，使用Mocha TDD接口，实现glob测试发现\n\n✅ Mocha配置验证通过，包括UI设置、颜色输出、测试文件发现模式和错误处理\n\n✅ 测试运行验证成功，npm test命令执行正常，VS Code测试环境正确加载，8个测试全部通过\n\n✅ 集成验证完成，测试编译、扩展编译、Linting均通过，完整测试流程正常工作\n\n无需额外配置，测试框架已完全集成并正常运行。\n</info added on 2025-06-07T05:55:17.894Z>\n<info added on 2025-06-07T06:13:52.177Z>\n✅ 测试方案重新设计完成！使用 @vscode/test-electron 实现了更标准和可靠的测试环境。\n\n## 重新设计的测试方案特点：\n\n### 1. 标准化的测试运行器 (src/test/runTest.ts)\n- ✅ 使用 `@vscode/test-electron` 的最佳实践\n- ✅ 支持指定 VS Code 版本 (通过环境变量 VSCODE_VERSION)\n- ✅ 完整的启动参数配置，包括禁用扩展、工作区信任等\n- ✅ 详细的日志输出和错误处理\n- ✅ 环境变量配置支持\n\n### 2. 增强的测试套件入口 (src/test/suite/index.ts)\n- ✅ 使用配置化的 Mocha 设置\n- ✅ 全局测试钩子 (beforeAll/afterAll)\n- ✅ 智能的测试文件发现和加载\n- ✅ 详细的测试执行反馈\n- ✅ 可配置的详细输出模式\n\n### 3. 专业的测试配置系统 (src/test/testConfig.ts)\n- ✅ 集中化的测试配置管理\n- ✅ 环境变量支持 (TEST_VERBOSE, VSCODE_VERSION, TEST_TIMEOUT)\n- ✅ VS Code 启动参数优化\n- ✅ Mocha 配置标准化\n- ✅ 可扩展的配置覆盖机制\n\n### 4. 完善的测试工具类 (src/test/testUtils.ts)\n- ✅ 类型安全的 VS Code API 模拟\n- ✅ 增强的 TextDocument 模拟 (支持范围文本提取、位置计算)\n- ✅ 完整的 ExtensionContext 模拟\n- ✅ TextEditor 模拟支持\n- ✅ 断言辅助函数 (assertCalled, assertCalledWith)\n- ✅ 测试环境辅助工具 (sleep, createTempWorkspaceFolder)\n\n### 5. 测试执行结果\n- ✅ 8个测试全部通过 (8 passing)\n- ✅ 执行时间：11ms\n- ✅ 找到2个测试文件\n- ✅ 全局设置和清理正常工作\n- ✅ VS Code 测试环境正确启动和关闭\n\n### 6. 环境变量支持\n# 启用详细输出\nTEST_VERBOSE=true npm test\n\n# 指定VS Code版本\nVSCODE_VERSION=1.85.0 npm test\n\n# 设置测试超时\nTEST_TIMEOUT=15000 npm test\n\n# 过滤测试\nMOCHA_GREP=\"ConfigurationManager\" npm test\n\n这个重新设计的测试方案提供了更专业、可维护和可扩展的测试基础设施，为后续的测试开发奠定了坚实的基础。\n</info added on 2025-06-07T06:13:52.177Z>",
          "status": "done",
          "testStrategy": "Manual verification by running npm test command"
        },
        {
          "id": 9,
          "title": "Implement Enhanced Test Utilities",
          "description": "Extend test utilities with advanced mocking capabilities",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Add TextEditor simulation with selection support\n2. Implement assertion helpers (assertCalled, assertCalledWith)\n3. Create temporary workspace folder utility\n4. Add async sleep function for timing tests\n5. Enhance document mock with range extraction capabilities\n<info added on 2025-06-07T07:20:16.871Z>\nAdd TabGroups and Tab simulation utility (createMockTabGroups)\nAdd file system simulation utility (createMockFileSystem)\nCreate test suite for test utilities (testUtils.test.ts) to verify all utility functions\n</info added on 2025-06-07T07:20:16.871Z>",
          "status": "pending",
          "testStrategy": "Verify new utilities through dedicated unit tests in testUtils.test.ts"
        },
        {
          "id": 7,
          "title": "Configure Code Coverage and Reporting",
          "description": "Set up code coverage instrumentation and reporting",
          "dependencies": [
            1,
            3,
            4,
            5
          ],
          "details": "1. Install coverage tool (nyc or c8). 2. Add coverage scripts to package.json. 3. Configure .nycrc for coverage thresholds. 4. Integrate with test runner. 5. Set up CI-friendly reporting format.\n<info added on 2025-06-07T07:21:53.233Z>\n1. Install coverage tool dependencies: nyc, c8, and @istanbuljs/nyc-config-typescript  \n2. Configure NYC via .nycrc.json with thresholds, reporters, include/exclude patterns  \n3. Configure C8 via .c8rc.json as alternative coverage solution  \n4. Update package.json scripts for coverage commands (test:coverage, coverage:report, etc.)  \n5. Modify test runner (runTest.ts) to integrate coverage with @vscode/test-electron  \n6. Extend testConfig.ts with coverage flags and threshold settings  \n7. Implement coverage-report.js script for summary generation and threshold validation  \n8. Update GitHub Actions workflow for coverage-enabled testing and Codecov integration  \n9. Document environment variables for coverage control (TEST_COVERAGE, COVERAGE_TOOL)  \n10. Establish coverage verification process: data generation, threshold checks, reporting, and CI/CD integration\n</info added on 2025-06-07T07:21:53.233Z>",
          "status": "pending",
          "testStrategy": "Verify coverage reports are generated and meet threshold requirements"
        },
        {
          "id": 8,
          "title": "Integration Testing and Manual Verification",
          "description": "Perform end-to-end test validation and manual checks",
          "dependencies": [
            1,
            2,
            3,
            4,
            5,
            6,
            7,
            9
          ],
          "details": "1. Run full test suite in VS Code environment. 2. Verify all tests pass in isolation and together. 3. Manually inspect test output and coverage reports. 4. Validate test failure scenarios. 5. Document test execution process.\n<info added on 2025-06-07T07:23:16.471Z>\n1. Implement end-to-end integration tests for the extension workflow, configuration changes, error handling, performance, and resource cleanup in src/test/suite/integration.test.ts\n2. Create comprehensive manual testing checklist in docs/manual-testing-checklist.md covering activation, file tracking, output generation, error scenarios, and performance\n3. Develop automated verification script (scripts/verify-tests.js) for compilation, linting, test execution, coverage checks, and test file validation\n4. Configure CI/CD pipeline (.github/workflows/comprehensive-test.yml) for multi-OS, multi-Node.js version, and multi-VSCode version testing\n5. Validate test environment compatibility across Ubuntu/Windows/macOS, Node.js 16.x/18.x, and VSCode stable/insiders versions\n</info added on 2025-06-07T07:23:16.471Z>",
          "status": "pending",
          "testStrategy": "Manual test execution and verification of test results in different environments"
        }
      ]
    }
  ]
}